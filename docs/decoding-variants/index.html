<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Decoding Variants · bs-decode</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Challenges With Variants"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Decoding Variants · bs-decode"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mlms13.github.io/bs-decode/"/><meta property="og:description" content="## Challenges With Variants"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/bs-decode/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><script src="/bs-decode/js/scrollSpy.js"></script><link rel="stylesheet" href="/bs-decode/css/main.css"/><script src="/bs-decode/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/bs-decode/"><h2 class="headerTitle">bs-decode</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/bs-decode/docs/what-and-why" target="_self">Docs</a></li><li class=""><a href="https://github.com/mlms13/bs-decode" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Decoding Guide</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/bs-decode/docs/what-and-why">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/simple-example">Simple Example</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/return-types">Return Types</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/working-with-errors">Working With Errors</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Decoding Guide</h3><ul class=""><li class="navListItem"><a class="navItem" href="/bs-decode/docs/decoding-simple-values">Simple Values</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/decoding-optional-values">Optional Values and Recovery</a></li><li class="navListItem"><a class="navItem" href="/bs-decode/docs/decoding-objects">Decoding Object Fields</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/bs-decode/docs/decoding-variants">Decoding Variants</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Decoding Variants</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="challenges-with-variants"></a><a href="#challenges-with-variants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Challenges With Variants</h2>
<p>Many types in Reason have a 1-to-1 mapping to JSON value types (think strings, ints, floats, arrays, etc). This is not true of Reason's variant types. While it's certainly possible to store variant values in JSON, the exact representation will vary depending on the preferences of the person who encoded the value.</p>
<p>At a high level, variant types in Reason are a way to represent &quot;or&quot; relationships in the type system. When decoding JSON, <code>alt</code> (and the related <code>oneOf</code>) allows you to express that a JSON value may have one representation &quot;or&quot; a different representation. This forms the foundation of decoding variants. We'll look at more specific examples below.</p>
<h3><a class="anchor" aria-hidden="true" id="simple-variants-enums"></a><a href="#simple-variants-enums" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple Variants (Enums)</h3>
<p>In their simplest form, Reason variant types are simply an enumeration of possible values, where each value carries no extra data. For example:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> color = Blue <span class="hljs-pattern-match">| <span class="hljs-constructor">Red</span> | <span class="hljs-constructor">Green</span>;
</span></code></pre>
<p>While there are a number of ways you could represent values of this type in JSON, let's assume that the values are encoded as the string values <code>&quot;blue&quot;</code> or <code>&quot;red&quot;</code> or <code>&quot;green&quot;</code>. In this case, you can write a decoder for each variant constructor and then combine them together using <code>alt</code> to form a single decoder:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> decodeBlue = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(literalString("blue") <span class="hljs-operator">|&gt;</span> map(_ =&gt; Blue))</span>;
<span class="hljs-keyword">let</span> decodeRed = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(literalString("red") <span class="hljs-operator">|&gt;</span> map(_ =&gt; Red))</span>;
<span class="hljs-keyword">let</span> decodeGreen = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(literalString("green") <span class="hljs-operator">|&gt;</span> map(_ =&gt; Green))</span>;

<span class="hljs-comment">// decode by chaining together `alt`</span>
<span class="hljs-keyword">let</span> decode = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(decodeBlue |&gt; alt(decodeRed) <span class="hljs-operator">|&gt;</span> alt(decodeGreen))</span>;

<span class="hljs-comment">// the same decoder, using `oneOf`</span>
<span class="hljs-keyword">let</span> decode = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span></span>one<span class="hljs-constructor">Of(<span class="hljs-params">decodeBlue</span>, [<span class="hljs-params">decodeRed</span>, <span class="hljs-params">decodeGreen</span>])</span>;
</code></pre>
<p>The need to decode string literals from JSON into simple Reason variants is common enough that we provide a <code>stringUnion</code> decoder that allows you to simply express the relationship between strings and variant values as pairs:</p>
<pre><code class="hljs css language-reasonml">let decode = Decode.stringUnion(
  ("blue", Blue),
  [("red", Red), ("green", Green)]
);
</code></pre>
<p>Whether you choose to use <code>alt</code>, <code>oneOf</code>, or <code>stringUnion</code>, you could expect the following outcomes when running your decode function:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-comment">// Ok(Blue)</span>
decode(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span><span class="hljs-module"><span class="hljs-identifier">Json</span>.</span></span><span class="hljs-built_in">string</span>(<span class="hljs-string">"blue"</span>));

<span class="hljs-comment">// Error(Val(`ExpectedValidOption, ...))</span>
decode(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span><span class="hljs-module"><span class="hljs-identifier">Json</span>.</span></span><span class="hljs-built_in">string</span>(<span class="hljs-string">"yellow"</span>));
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="complex-variants"></a><a href="#complex-variants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Complex Variants</h3>
<p>Not all variants are as simple as our <code>color</code> variant above. Often, each branch of a Reason variant could carry its own additional data. Consider the following:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> shape =
  <span class="hljs-pattern-match">| <span class="hljs-constructor">Rectangle(<span class="hljs-params">float</span>, <span class="hljs-params">float</span>)</span>
  | <span class="hljs-constructor">Square(<span class="hljs-params">float</span>)</span>
  | <span class="hljs-constructor">Circle(<span class="hljs-params">float</span>)</span>;
</span></code></pre>
<p>There are countless ways this data could be represented in JSON, but let's assume the following valid representations:</p>
<pre><code class="hljs css language-json">[
  { <span class="hljs-attr">"type"</span>: <span class="hljs-string">"rectangle"</span>, <span class="hljs-attr">"width"</span>: <span class="hljs-number">2.5</span>, <span class="hljs-attr">"height"</span>: <span class="hljs-number">4</span> },
  { <span class="hljs-attr">"type"</span>: <span class="hljs-string">"square"</span>, <span class="hljs-attr">"side"</span>: <span class="hljs-number">3</span> },
  { <span class="hljs-attr">"type"</span>: <span class="hljs-string">"circle"</span>, <span class="hljs-attr">"radius"</span>: <span class="hljs-number">1.8</span> }
]
</code></pre>
<p>There's a little more to it now, but the same general strategy from before will still work. We can write a decoder for each possible variant branch, then we combine each decoder together using <code>oneOf</code>:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> decodeRectangle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(
  map3(
    (_, width, height) =&gt; <span class="hljs-module"><span class="hljs-identifier">Rectangle</span>(</span>width, height)</span>,
    field(<span class="hljs-string">"type"</span>, literal<span class="hljs-constructor">String(<span class="hljs-string">"rectangle"</span>)</span>),
    field(<span class="hljs-string">"width"</span>, floatFromNumber),
    field(<span class="hljs-string">"height"</span>, floatFromNumber),
  )
);

<span class="hljs-keyword">let</span> decodeSquare = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(
  map2(
    (_, side) =&gt; <span class="hljs-module"><span class="hljs-identifier">Square</span>(</span>side)</span>,
    field(<span class="hljs-string">"type"</span>, literal<span class="hljs-constructor">String(<span class="hljs-string">"square"</span>)</span>),
    field(<span class="hljs-string">"side"</span>, floatFromNumber),
  )
);

<span class="hljs-keyword">let</span> decodeCircle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span>(
  map2(
    (_, radius) =&gt; <span class="hljs-module"><span class="hljs-identifier">Circle</span>(</span>radius)</span>,
    field(<span class="hljs-string">"type"</span>, literal<span class="hljs-constructor">String(<span class="hljs-string">"circle"</span>)</span>),
    field(<span class="hljs-string">"radius"</span>, literal<span class="hljs-constructor">String(<span class="hljs-string">"radius"</span>)</span>),
  )
);

<span class="hljs-keyword">let</span> decode = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Decode</span>.</span></span>one<span class="hljs-constructor">Of(<span class="hljs-params">decodeRectangle</span>, [<span class="hljs-params">decodeSquare</span>, <span class="hljs-params">decodeCircle</span>])</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="extending-base-errors-deprecated"></a><a href="#extending-base-errors-deprecated" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending Base Errors (Deprecated)</h2>
<p><strong>Note:</strong> for complex variants, the above strategies involving <code>alt</code> already give you very detailed error information about each decoder that was attempted and failed. The downside of that approach is that <code>stringLiteral</code> decoders currently don't report back the specific string that the decoder was looking for. In the future, those errors will be improved, and the method of extending the error type itself (described below) will be removed.</p>
<p>In some cases, <code>ExpectedValidOption</code> might not be enough debugging information. You may want custom handling (or simply, more specific error messages) when something goes wrong during decoding.</p>
<p>You can get this by extending the underlying <code>Decode.ParseError.base</code> type with extra constructors. You use this extension to build your own custom <code>Decode.ParseError</code>, which in turn can be used to build a custom decode module on top of <code>Decode.Base</code>.</p>
<p>This may sound overwhelming, but the whole thing can be accomplished in about 6 lines of code:</p>
<pre><code class="hljs css language-reasonml">module R =
  Decode.ParseError.ResultOf({
    type t = [ Decode.ParseError.base | `InvalidColor | `InvalidShape];
    let handle = x =&gt; (x :&gt; t);
  });

module D = Decode.Base.Make(R.TransformError, R);
</code></pre>
<p>Now we have a <code>D</code> that is slightly different from the <code>Decode.AsResult.OfParseError</code> that we've been using up until now. This <code>D</code> can produce <code>Val</code> parse errors that can include <code>InvalidColor</code> or <code>InvalidShape</code> (in addition to the usual error cases).</p>
<p>We can change the <code>parseColor</code> function we defined above to return a Result where the Error is of type <code>InvalidColor</code> and it includes the specific piece of JSON we were trying to parse, for detailed debugging:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> parseColor =
  <span class="hljs-keyword">fun</span>
  <span class="hljs-pattern-match">| "<span class="hljs-constructor">Blue</span>" =&gt;</span> <span class="hljs-constructor">Ok(Blue)</span>
  <span class="hljs-pattern-match">| "<span class="hljs-constructor">Red</span>" =&gt;</span> <span class="hljs-constructor">Ok(Red)</span>
  <span class="hljs-pattern-match">| "<span class="hljs-constructor">Green</span>" =&gt;</span> <span class="hljs-constructor">Ok(Green)</span>
  <span class="hljs-pattern-match">| str =&gt;</span> <span class="hljs-constructor">Error(Decode.ParseError.Val(`InvalidColor, Js.Json.<span class="hljs-params">string</span>(<span class="hljs-params">str</span>)</span>));

<span class="hljs-keyword">let</span> decodeColor =<span class="hljs-function"> <span class="hljs-params">json</span> =&gt;</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">D</span>.</span></span><span class="hljs-built_in">string</span>(json)<span class="hljs-operator"> |&gt; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>flat<span class="hljs-constructor">Map(<span class="hljs-params">parseColor</span>)</span>;
</code></pre>
<p>Now we have a <code>decodeColor</code> function that produces the same output type as any other <code>decode</code> function we may write, but it includes error information specific to our <code>color</code> parsing.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/bs-decode/docs/decoding-objects"><span class="arrow-prev">← </span><span>Decoding Object Fields</span></a><a class="docs-next button" href="/bs-decode/docs/result-of-parseerror"><span>Next</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#challenges-with-variants">Challenges With Variants</a><ul class="toc-headings"><li><a href="#simple-variants-enums">Simple Variants (Enums)</a></li><li><a href="#complex-variants">Complex Variants</a></li></ul></li><li><a href="#extending-base-errors-deprecated">Extending Base Errors (Deprecated)</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div><a href="https://github.com/mlms13/bs-decode">GitHub</a></div></section><section class="copyright">Copyright © 2023 Michael Martin</section></footer></div></body></html>